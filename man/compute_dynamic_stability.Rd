% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dynamic_stability_functions.R
\name{compute_dynamic_stability}
\alias{compute_dynamic_stability}
\title{compute_dynamic_stability}
\usage{
compute_dynamic_stability(block,
  results_file = "output/portal_ds_results.RDS", max_E = 16,
  E_list = seq(max_E), surrogate_method = "annual_spline",
  num_surr = 200, surr_params = list(), lib_sizes = c(6, 12, 24, 40,
  80, 140, 220, 320, NROW(results$block)), num_samples = 200,
  num_cores = 2, rescale = TRUE, rolling_forecast = FALSE)
}
\arguments{
\item{block}{a data.frame containing time series for the community. Each
column is a time series of abundances.}

\item{results_file}{the location of the results to be stored on disk.}

\item{max_E}{largest E to examine using simplex projection; this sets the
default range for `E_list`, but any setting for `E_list` will override the
value for `max_E`}

\item{E_list}{the embedding dimension or range of embedding dimensions to
search over.}

\item{surrogate_method}{which surrogate method to use: 
options are "annual_spline" or methods available in 
\code{\link[rEDM]{make_surrogate_data}}}

\item{num_surr}{number of surrogates to compute}

\item{surr_params}{a list of named optional arguments to be passed into the 
surrogate data function}

\item{lib_sizes}{the vector of library sizes to try}

\item{num_samples}{is the number of random samples at each lib size (this 
parameter is ignored if random_libs is FALSE)}

\item{num_cores}{the number of cores to use for computation}

\item{rescale}{A logical, indicating whether to rescale each time series}

\item{rolling_forecast}{A logical, indicating whether to make individual
rolling forecasts for the second half of the time series.}
}
\value{
none
}
\description{
Full dynamic stability analysis for community time series. The
  analysis has multiple components:
  (1) run simplex projection on each time series to identify the optimal
      embedding dimension
  (2) generate surrogate time series, assumming that the data have just a
      seasonal pattern
  (3) run ccm on each pairwise interaction, including the surrogate data
  (4) identify the significant interactions by comparing the CCM for the real
      time series against the calculations for the surrogate data
  (5) run S-map models for each time series, using the appropriate number of
      lags, and including the important interacting variables
  (6) extract out the s-map coefficients from the models and assemble
      matrices for the system
  (7) perform eigen-decomposition on the s-map coefficient matrices
}
